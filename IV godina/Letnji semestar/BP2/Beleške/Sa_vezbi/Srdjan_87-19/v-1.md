sql server se konfigurise tako da se smanje troskovi

jedna od ideja za optimizaciju je da se ubrza rad kroz koriscenje indeksa, gde se optimizacija u stvari vrsi nad IO operacijama posto su one dosta spore

indeksi ne povecvaju broj funkcionalnosti sistema, ali poboljsavaju upotrebljivost sistema

indeks - struktura podataka koja ubrzava pretrazivanje podataka u bazi

data engine-i najcesce ne rasporedjuju pristigle podatke, vec ocekuju da ti podaci kasnije budu sortirani

podaci se redjaju na "gomilu" (heap)


ms sql 

tabela se posmatra kao skup stranica
nije stvarna reprezentacija, to su u memoriji blokovi, ali dbms ih tako posmatra (svuda osim u storage manageru)


# Heap

neuredjena kolekcija stranica

ako se za rasporedjivanje ne koriste indeksi onda su podaci organizovani kao heap

ako zafale stranice one se alociraju i dodaju heap-u i na taj nacin se tabela siri

ovaj nacin je efikasan jer stedi prostor.
nema ogranicenja na prostor podataka.
nije potrebno da se trazi prazno mesto na koje bi se novi podaci umetnuli, ali nema nikakav vide uredjenja i sortiranja podataka, sto otezava pretragu

da bi se nasao podatak koji zadovoljava upit potrebno je da se prodje kroz ceo heap. To se naziva table scan-om. 

Priihvatljivo je kada se trazi cela tabela. Za sve drugo nije korisno.

# Indeksi

resavaju problem sa uslovima koje ima heap.

Sadrze kopiju dela podataka iz tabela, tj. jednu ili vise kolona. 

Kolone u indeksu predstavljaju kljuc pretrage (search key). Na osnovu njega se vrsi pretraga.


indeks = (kljuc_pretrag, pokazivac)

sql server koristi balansirano B stablo kao strukturu indeksa

u listovima se nalaze sami podaci, dok su u ostalim cvorovima pokazivaci

stablo je balansirano => svi listovi se nalaze na relativno istom rastojanju od korena

u jednom cvoru se moze naci vise podataka iz zapisa

svaki cvor je jedna stranica

listovi su sortirani prema kljucu pretrage

svaki nivo je povezan dvostrukom listom kako bi moglo kroz te nivoe da se prolazi brzi

sami listovi mogu da sadrze pokazivace ili stranicu tabele

query processor krece od root cvora i onda uporedjuje vrednost sa indeksnim kljucevima, ne ucitavaju se neke 
stranice koje ne ispunjavaju uslov pa se manje memorije zauzima (tj. umesto ucitavanja cele stranice koja sadrzi
podatke ucitava se vise indeksa, a time se i ubrzava proces pretrage jer su dostupniji podaci koji su relevantni
za donosenje odluke)

indeksi kod kojih se u listovima nalaze fizicki podaci nazivaju se **klasterizovani indeksi**

# Klasterizovani indeksi

> podaci su fizicki sortirani na nivou stranice na osnovu klasterovanog kljuca pretrage

kljuc pretrage ne mora da bude PK ili samo jedna kolona. Najcesce jeste PK (default pri postavljanju PK)

kreira se b-stablo nad fizicki uredjenim podacima


stranice tabele se mogu posmatrati kao listovi, u listovima se nalaze stranice

pretragom se dolazi do stranice u kojoj se zapis nalazi (ili do njenog okruzenja). 

Ne mozemo ucitati samo zapis jer je najmanja jedinica stranica

podaci tabele su rasporedjani sekvencijalno, po kljucu pretrage

kada se postavi primarni kljuc automatski se postavlja da bude i klasterizovani indeks.

**Najvise 1 klasterovani indeks moze da se formira za 1 tabelu**  
(zasto? zato sto podaci mogu da se sortiraju samo na jedan nacin u jednom trenutku)


# Neklasterovani indeksi

Ne sadrze fizicke podatke (stranice) u listovima, vec pokazivac ka toj stranici

Pokazivaci (tj. vrednosti kljuca) su sortirani

Ne utice na fizicku organizaciju podataka. Podaci (stranice) se ne nalaze u listovima. 
Zbog toga mozemo da imamo **vise** od jednog indeksa ovog tipa nad jednom tabelom

# Poredjenje klasterovanog i neklasterovanog

Klasterovani moze da se zamisli kao telefonski imenik, 
a neklasterovani kao indeks pojmova koji se nalazi na kraju knjige, kao
> pojmovi su razbacani po celoj knjizi, a za svaki se navodi sortirana lista 
stranica na kojima se oni nalaze



Klasterizovan indeks nam omogucava da dodjemo do okoline podatka. Kada se dodje do nje i
dati podatak ne nadje na datoj stranici onda se sekvencijalno pretrazuju stranice dalje 
dok se ne dodje do datog podatka


Kod neklasterovanog se preko pokazivaca dolazi direktno do stranice, ne pretrazuju
se sekvencijalno stranice kao kod klasterovanog.

Listovi neklasterovanog indeksa su uredjeni.

# Praktican rad

pri dodavanju (attach-ovanju) baze uncheck-irati checkbox za log


tool koji cemo koristiti se zove `Estimated Execution Plan`, nalazi desno od
dugmeta `Execute` (2-3 dugmeta desno; `Display Estimated Execution Plan`).  
Pomocu njega mozemo da dobijemo procenu troskova bez pokretanja samog upita.
Potrebno je da se taj upit selektuje i da se nakon toga klikne spomenuto dugme 


Table Scan - cita se stranica po stranica 
(radi se kada nema indeksa nad tabelom)


U execution planu postavljanjem misa na odredjenu akciju mozemo da vidimo neke metrike.
Mi cemo posmatrati `Estimated Operator Cost`, `Estimated Number of Rows Per Executions`
(broj vrsta koje ce biti ucitan u radnu memoriju kako bi se upit izvrsio) i
`Estimated Number of Rows to be Read`


Ako postoji klasterovani indeks nad tabelom onda ce umesto `Table Scan` pisati
`Clustered Index Scan`


Troskovi pretrage pomocu klasterovanog indeksa u odnosu na Table Scan se ne menjaju
ukoliko se zahteva cela tabela.

Kreiranje neklasterovanog indeksa:
```SQL 
create nonclustered index inx_first
on person(firstname);
```

Sve indekse koji su definisani nad tabelom mozemo da nadjemo u hijerarhiji same tabele
u folderu `Indexes`

Brisanje indeksa:
```SQL
drop index Person.idx_first
```
