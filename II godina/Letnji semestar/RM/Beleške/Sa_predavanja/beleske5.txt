Datum odrzavanja: 23.03.2021.
Predavac: Miloš Ivanović
Cas: 5
=====================================

Model - uproscena slika realnosti


Pretpostavke modela koji cemo izucavati:
1. svaki sloj se odigrava poseban proces
2. uredjaj A zeli da posalje racunaru B dugacak niz bitova koristeci pouzdanu
   direktnu vezu
3. racunari rade besprekorno ( greske nastaju samo u njihovoj komunikaciji )
4. mrezni sloj uvek ima paket za slanje



3. se pretpostavlja jer se ovo proucavanje fokusira na razumevanje komunikacije pa
je u tom slucaju to moguce zanemariti



CRC se hardverski racunari


Dogadjaji koji mogu da se dese:
1. cksum_error
2. frame_arrival
3. timeout


Redni broj okvira moze da bude u opsegu od 0 do MAX_SEQ-1


makro inc() inkrementira redni broj i vraca ga na 0 ako dodje do maksimuma
to je makro zato sto se nalazi u kriticnoj sekciji. Da je funkcija to bi dosta uticalo
na performanse


postoji nekoliko vrsta okvira:
1. data
2. ack(nowladgment) - pozitivna potvrda
3. nak, tj. n(egative)a(c)k(nowladgment) - negativna potvrda


nak se koristi za obavestavanje posiljaoca o tome da je potrebno ponovo poslati
odredjeni okvir



Struktura okvira:
- kind ( vrsta okvira )
- seq ( redni broj okvira )
- ack ( potvrda o prispecu prethodog okvira )
- info ( podaci, tj. paket )



funckija "void start_timer(seq_nr k)" pokrece tajmer za okvir k


Postoje i funckije za omogucavanje i onemogucavanje mreznog sloja. Koriste se kada se
bafer prepuni ili kada se oslobodni prostor na njemu nakon tog punjanja






Protokol za neogranicen jednosmeran prenos podataka (utopija)
-------------------------------------------------------------
- najjednostavniji protokol koji je potpuno nerealan
- obezbedjuje prenos u samo jednom smeru
- pretpostavlja se da greska ne moze da se pojavi na komunikacionom kanalu
- pretpostavlja se da prijemnik moze beskonacno brzo da obradjuje podatke koji mu pristizu
- pretpostavlja se da su baferi neogranicene velicine



Slanje paketa:
Funkcijom "from_network_layer" se uzima paket iz mreznog sloja i paket se smesta 
u bafer. 
Dalje se paket iz bafera premesta i pakuje u okvir.
Funkcijom "to_physical_layer" dati okvir se salje drugom uredjaju


Primanje paketa:
ceka se dogadjaj pomocu f-je "wait_for_event" (u ovom protokolu postoji samo
frame_arrival)
Funkcijom "from_physical_layer" preuzima se pristigli okvir iz fizickog sloja
Funkciji "to_network_layer" paket sadrzan u datom okviru se presledjuje
mreznom sloju


Nema kontrolu toka, kao ni kontrolu greske. Jedino sto radi je uokviravanje





Simplex protokola (stop & wait)
--------------------------------
- vazi sve sto i kod protokola "utopia" osim pretpostavke da primalac moze
   (beskonacno brzo??) da obradi sve sto mu posiljalac posalje
- umesto odbacene pretpostavke uvodi se feedback flow control; posiljalac moze da
  salje okvire samo ako mu primalac javi da je moze da ih obradi
- primalac nakon obrade salje prazan okvir (dummy frame) kako bi posiljaoca obavestio
  da moze da nastavi sa slanjem okvira
  
Dodatak u odnosu na protokol "utopia" cine
- poziv funkcije "init_frame" unutar beskonacne while petlje 
  kojom se inicijalizuje okvir
- poziv funkcije "wait_for_event" kojom posiljalac ceka potvrdu 
  da moze da nastavi sa slanjem
- poziv funkcija "init_frame" izvan beskonacne while petlje 
  kojom se inicijalizuje okvir (nalazi se izvan jer je rec o 
  praznom, kontrolnom okviru koji je uvek isti pa nije potrebno 
  raditi inicijalizaciju pri svakom prolazu)
- poziv funkcije "to_physical_layer" koja salje prazan okvir
  kojim se posiljalac obavestava da moze da nastavi sa slanjem


To sto je protokol "jednosmeran" ne znaci da se saobracaj koji
prolazi kroz medijum tece u jednom smeru vec da se prenos
podataka odvija samo u jednom smeru, dok drugi saobracaj koji
se npr. odnose na kontrolu komunikacije mogu kretati i u drugom
smeru. Ovaj nacin "jednosmerne" komunikacije naziva se simplex






Simplex protokol za slanje podataka bucnim kanalom ( PAR / ARQ )
----------------------------------------------------------------
- nadogradnja stop & wait protokola kod koje se odbacuje pretpostavka da je komunikacioni
  kanal besuman, tj. da ne moze doci do greske
- pretpostavlja se da hardver ume da izracuna kontrolni zbir
- uvodi se tajmer kako posiljalac ne bi cekao beskonacno dugo na potvrdu koja se izgubila
- ukoliko se okvir primi, a potvrda izgubi dolazi do duplog prijema. Zbog toga se uvodi
  broj sekvence, tj. redni broj okvira
- zove se i jednobitni protokol jer se u jednom trenutku na medijumu nalazi samo jedan
  okvir, 0 ili 1 (kao i protokoli 1,2 i 4)
- uvode se varijable "next_frame_to_send" i "frame_expected" koji se inicijalizaciju na 0



Sender:

nakon slanja okvira ukljucuje se njegov tajmer i funkijom "wait_for_event" ceka se na
neki dogadjaj (blokira se proces)

kada se neki dogadaj dogodi dolazi do odblokiranja procesa i proveravanja do kog 
dogadjaja je doslo

ako se dogodio "frame_arrival", znaci da je doslo do nekog dogadjaja, uzima se okvir
iz fizickog sloja i proverava se da li je okvir koji je poslat uspesno stigao. 

Ukoliko jeste iz mreznog sloja se uzima naredni okvir i "next_frame_to_send" se inkrementira (posto se radi o 1-bitnom protokolu to inkremetiranje daje isti rezultat
kao i invertovanje)




Receiver:

moze da primi 2 vrste dogadjaja:
1. frame_arrival
2. cksum_error


Bokira se i ceka neki od dogadjaja.

Ako je u pitanju "frame_arrival" uzima okvir iz fizickog sloja i proverava da li je to
okvir koji je ocekivao. Ako jeste salje se mreznom sloju i inkrementira se "frame_expected"
a ukoliko nije to se ne radi sto omogucava da se mreznom sloju primaoca ne posalje 2 puta
isti okvir


Dalje se inicijalizuje kontrolni okvir koji ce da se posalje posiljaocu i njegova varijabla
koja sadrzi redni broj okvira koji se potvrdjuje dobija vrednost. 

Nakon toga kontrolni okvir se salje posiljaocu.


Ukoliko je se dogodio "cksum_error", nista se ne desava, kod u petlji krece ponovo da se
izvrsava




Pri pravljenju protokola cilj je da se minimizuje broj metapodataka i njihova velicina
kako bi medijum prenosio veci broj podataka korisnih za korisnika 


Okviri mogu da budu varijabilne duzine (kod etherneta i jesu)



Vrednost tajmera varira zavisno od kabla. Postavlja se na vrednost koja predstavlja vreme
koje je potrebno da kabl najvece dozvoljene duzine za dati tip prenese okvir primaocu i
njegovu potvrdu posiljaocu, tj. vreme round trip-a tog okvira. Ona se odredjuje iskustveno
i fiksna je za dati tip mreze, tj. standarda




==========================================
Protokoli kliznih prozora (sliding window)
==========================================


1-bitni protokol kliznih prozora 
--------------------------------
- jednobitni protokol (prvi protokol iz ove klase, ostali nisu)
- promena u odnosu na PAR protokol je to sto se omogucava dvosmerna komunikacija; duplex
- ne koristi 2 procedure, vec jednu i za posiljaoca i za primaoca
- uvode se slepovanje i klizni prozori

Uvodi se tehnika koja se naziva slepovanje (piggybacking). Posto okviri imaju i deo za
potvrdu unutar sebe, mogu se iskoristiti tako sto ce se umesto slanja praznog okvira sa
potvrdom slati i podaci sa koje drugi uredjaj treba da posalje prvom. Drugi racunar ceka 
neko vreme da od svog mreznog sloja dobije okvir za slanje i tada sa tim podacima salje
potvrdu o prijumu okvira prvom racunaru. 

Ukoliko drugi uredjaj nakon nekoliko milisekundi ne dobije od svog mreznog sloja okvir za
prvi, on ce poslati prazan okvir sa potvrdom jer ukoliko bi previse cekao onda bi tajmer
istekao i doslo bi do ponovnog slanja sto bi obesmislilo ovu tehniku.



Prozori predstavljaju redne brojeve (sequence numbers) okvira sa kojima okvir trenutno radi


Npr. kod posiljaoca to bi bio okvir koji tek treba da se posalje, tj. "next_frame_to_send"
kao i okviri koji su vec poslati, ali za njih potvrda jos nije stigla


Kod posiljaoca to su redni brojevi okvira koje u tom trenutku moze da primi



Prozor posiljaoca je zatvoren ako se obe granice poklapaju (graficki prikaz prozora)
Kada posalje okvir njegov prozor se otvara, tj. jedna od tih granica se pomera za jedno 
polje, tj. prozor.


Prozor primaoca je u pocetku otvoren. Kada primi okvir obe granice se pomeraju za jedan
prozor. Prozor kod njega predstavlja "frame_expected"


Kada posiljalac dobije potvrdu, leva granica se pomera za jedno polje/prozor, tj. taj 
prozor se zatvara i granice se nalaze na istom mestu



Komunikacija se odigrava dvosmerno pa se vise ne koriste 2 procedure


Komunikacija u dva smera se vrsi kroz jedan medijum. To je moguce postici i sa dva 
medijuma, jednim za saobracaj koji salje prvi uredjaj drugom i drugi medijum za prenos
saobracaja od drugog ka prvom. Mana takvog pristupa je efikasnost, jer iako su na 
raspolaganju 2 medijuma, samo je jedan moguce koristiti za slanje pa je prenos ogranicen
na propusni opseg jednog takvom medijuma.


Kod:

Prvo se radi inicijalizacija. Nakon toga se ulazi u petlji i ceka se da se nesto dogodi.
Dogadjaji koji mogu da se dogode su: "frame_arrival", "cksum_error" i "timeout"


Ukoliko je "frame_arrival", okvir se uzima iz fizickog sloja i proverava se da li je
je on ocekivan. Ukoliko jeste uzima se paket koji je upakovan u njemu i prosledjuje se
mreznom sloju pa se inkrementira "frame_expected", tj. pomera prozor "primaoca". Ukoliko
pristigli paket nije onaj koji je ocekivan nista se ne dogadja.


Dalje se proverava da li je potvrda koja je deo pristiglog okvira potvrda za okvir koji je
dati uredjaj prethodno poslao, tj. da li je jednaka vrednosti "next_frame_to_send".
Ukoliko jeste uzima se paket iz mreznog sloja i inkrementira se "next_frame_to_send", tj.
pomera prozor "posiljaoca". Ukoliko nije niste se ne desava



Nakon toga, inicijalizuje se okvir koji ce se poslati drugom uredjaju, dobija odgovarajuce
podatke (paket i kontrolne podatke), prosledjuje se fizickom sloju i pokrece njegov tajmer



Razlika u odnosu na PAR protokol je to sto su procedure za slanje i primanje okvira 
objedinjene i to sto se vise ne salju prazni okviri sa potvrdom vec se ona "kaci" na 
okvir koji uredjaj koji je primio taj okvir salje drugom uredjaju (koji je taj okvir
poslao)


I jedan i drugi uredjaj u ovom protokolu izvrsavaju kod za inicijalizaciju, ali samo jedan
ce moci prvi da to odradi. Ako se i desi da oba u istom trenutku izvrse kod


Ako dodje do lose sinhronizacije, tj. ako i uredjaj A salje uredjaju B okvir u isto vreme
kada uredjaj B salje uredjaju A okvir doci ce do kasnjenja potvrda, pa time i do slanja
duplikata. U ovakvom slucaju dolazi do smanjenja performansi, ali ne moze da dodje do
slanja duplikata mreznom sloju



Protokol tipa "vrati se N" (go-back-N)
--------------------------------------

U 1-bitnom protokolu kliznih prozora postoji mogucnost da se u jednom trenutku prenosi 
najvise 1 okvir. Dok se ne potvrdi prijem tog okvira posiljalac nece nista raditi (
osim ponovnog slanja ). Ukoliko je prenos sa jednog kraja da drugi spor, posiljalac bi
cekao blokiran veoma dugo, besposlen.


Iskoriscenost linije je I / ( I + b * R ), gde je b brzina kanala, I velicina okvira u 
bitovima, a R ukupno vreme prolaska vezom (round-trip)



Resenje ovog problema je omogucavanje da se vise okvira salje u sto vreme, tako da dok 
posiljalac ceka potvrdu on salje okvire. 



Ovaj protokol se zove "vrati se N" zato sto se, ukoliko dodje do greske, okviri ponovo 
salju od mesta na kojem je doslo do greske, tj. "vraca" se N okvira.


To se desava zbog toga sto primalac ima samo jedan prozor, a mora da primi okviri redom, pa
je jedini nacin da se to pravilo zadovolji ponavljanje poslednjih N bitova, tj. svih okvira
od okvira na kojem je nastala greska.



U odnosu na 1-bitni protokol kliznog prozora, u ovom protokolu broj prozora posiljaoca je
prosiren, dok je broj prozora primaoca ostao isti.


Ako posiljalac ne primi potvrdu za neki okvir, a primi za okvire koji slede nakon njega
onda ce posiljalac prihvatiti i taj okvir iako za njega nije stigla potvrda jer posiljalac
ne moze da dobije potvrdu nekog narednog okvira ako taj ovkir pre toga nije obradjen;
Mora da dobije potvrdu za trenutni da bi presao na naredni


Postoji i NAK (Negative Acknowledgement) koji je opcioni. Ukoliko se koristi moze da 
poveca brzinu tako sto ce se njime nagovestiti posiljaocu da okvir nije primljen pa on nece
morati da ceka da mu istekne tajmer da bi poslao okvir vec ce moci odmah da ga posalje



Odbacuje se pretpostavka da mrezni sloj uvek ima nesto za slanje.
To se definise kao dogadaj "network_layer_ready"


Ako dodje do prepunjavanja bafera onda se bafer onemogucujuje kako
se DLL ne bi zagusio i time izgubio okvire


Na kanalu moze istovremeno biti najvise MAX_SEQ okvira, a ne 
MAX_SEQ+1. 


[ ako je MAX_SEQ=7, onda u prozoru imamo numerisane okvire sa 
  0,1,2,3,4,5,6,7; na kanalu se u istom trenutku ne moze naci svih
  8 okvira, vec 7 ]

  
Ukoliko bi se prenosilo svih 8 okvira, postojala bi mogucnost da 

-5
